package io.github.sergkhram.idbClient.entities.requestsBody.xctest

import idb.XctestRunRequest

sealed class XctestRunRequestBody {
    abstract val requestBody: XctestRunRequest

    /**
     * Run an installed logic test. Will pass through any environment variables prefixed with IDB_
     * @param testBundleId - Bundle id of the test to launch
     * @param reportActivities - idb will report activity data emitted by your test bundle
     * @param reportAttachments - idb will report activity and attachment data emitted by your test bundle
     * @param collectCoverage - collect coverage or not
     * @param collectLogs - collect logs or not
     * @param waitForDebugger - Suspend test run process to wait for a debugger to be attached. (It is NOT supported by ui test).
     * @param collectResultBundle - collect result bundle or not
     * @param coverageFormat - Format for code coverage information: "
    "EXPORTED (default value) a file in JSON format as exported by `llvm-cov export`; "
    "RAW a folder containing the .profraw files as generated by the Test Bundle, Host App and/or Target App
     * @param testsToRun - Run these tests only. if not specified all tests are run. Format: className/methodName
     * @param testsToSkip - Skip these tests, has precedence over --tests-to-run. Format: className/methodName
     * @param env - env map
     * @param args - Arguments to start the test with
     * @param timeout - The number of seconds to wait before the test times out. When the timeout is exceeded the test
     * will exit and an attempt will be made to obtain a sample of the hung process
     */
    data class LogicXctestRequestBody(
        val testBundleId: String,
        val reportActivities: Boolean,
        val reportAttachments: Boolean,
        val collectCoverage: Boolean,
        val collectLogs: Boolean,
        val waitForDebugger: Boolean,
        val collectResultBundle: Boolean,
        val coverageFormat: CodeCoverageFormat?, //required for collectCoverage = true
        val testsToRun: List<String> = emptyList(),
        val testsToSkip: List<String> = emptyList(),
        val env: Map<String, String> = emptyMap(),
        val args: List<String> = emptyList(),
        val timeout: Long = 0L,
    ) : XctestRunRequestBody() {
        override val requestBody: XctestRunRequest = XctestRunRequest.newBuilder()
            .setMode(XctestRunRequest.Mode.newBuilder().setLogic(XctestRunRequest.Logic.getDefaultInstance()))
            .setTestBundleId(testBundleId)
            .setReportActivities(reportActivities)
            .setReportAttachments(reportAttachments)
            .setCollectCoverage(collectCoverage)
            .setCollectLogs(collectLogs)
            .setWaitForDebugger(waitForDebugger)
            .setCollectResultBundle(collectResultBundle)
            .putAllEnvironment(env)
            .addAllArguments(args)
            .setTimeout(timeout)
            .addAllTestsToRun(testsToRun)
            .addAllTestsToSkip(testsToSkip)
            .build().apply {
                if(collectCoverage) {
                    this.toBuilder().setCodeCoverage(
                        XctestRunRequest.CodeCoverage.newBuilder().setFormatValue(coverageFormat?.value ?: 0).build()
                    ).build()
                }
            }
    }

    /**
     * Run an installed ui test. Will pass through any environment variables prefixed with IDB_
     * @param testBundleId - Bundle id of the test to launch
     * @param appBundleId - Bundle id of the app to test
     * @param reportActivities - idb will report activity data emitted by your test bundle
     * @param reportAttachments - idb will report activity and attachment data emitted by your test bundle
     * @param collectCoverage - collect coverage or not
     * @param collectLogs - collect logs or not
     * @param waitForDebugger - Suspend test run process to wait for a debugger to be attached. (It is NOT supported by ui test).
     * @param collectResultBundle - collect result bundle or not
     * @param coverageFormat - Format for code coverage information: "
    "EXPORTED (default value) a file in JSON format as exported by `llvm-cov export`; "
    "RAW a folder containing the .profraw files as generated by the Test Bundle, Host App and/or Target App
     * @param testHostAppBundleId - Bundle id of the app that hosts ui test
     * @param testsToRun - Run these tests only. if not specified all tests are run. Format: className/methodName
     * @param testsToSkip - Skip these tests, has precedence over --tests-to-run. Format: className/methodName
     * @param env - env map
     * @param args - Arguments to start the test with
     * @param timeout - The number of seconds to wait before the test times out. When the timeout is exceeded the test
     * will exit and an attempt will be made to obtain a sample of the hung process
     */
    data class UIXctestRequestBody(
        val testBundleId: String,
        val appBundleId: String,
        val reportActivities: Boolean,
        val reportAttachments: Boolean,
        val collectCoverage: Boolean,
        val collectLogs: Boolean,
        val waitForDebugger: Boolean,
        val collectResultBundle: Boolean,
        val coverageFormat: CodeCoverageFormat?, //required for collectCoverage = true
        val testHostAppBundleId: String = "",
        val testsToRun: List<String> = emptyList(),
        val testsToSkip: List<String> = emptyList(),
        val env: Map<String, String> = emptyMap(),
        val args: List<String> = emptyList(),
        val timeout: Long = 0L,
    ) : XctestRunRequestBody() {
        override val requestBody: XctestRunRequest = XctestRunRequest.newBuilder()
            .setMode(
                XctestRunRequest.Mode.newBuilder()
                    .setUi(
                        XctestRunRequest.UI.newBuilder()
                            .setAppBundleId(appBundleId)
                            .setTestHostAppBundleId(testHostAppBundleId)
                            .build()
                    )
            )
            .setTestBundleId(testBundleId)
            .setReportActivities(reportActivities)
            .setReportAttachments(reportAttachments)
            .setCollectCoverage(collectCoverage)
            .setCollectLogs(collectLogs)
            .setWaitForDebugger(waitForDebugger)
            .setCollectResultBundle(collectResultBundle)
            .putAllEnvironment(env)
            .addAllArguments(args)
            .setTimeout(timeout)
            .addAllTestsToRun(testsToRun)
            .addAllTestsToSkip(testsToSkip)
            .build().apply {
                if(collectCoverage) {
                    this.toBuilder().setCodeCoverage(
                        XctestRunRequest.CodeCoverage.newBuilder().setFormatValue(coverageFormat?.value ?: 0).build()
                    ).build()
                }
            }
    }

    /**
     * Run an installed application test. Will pass through any environment variables prefixed with IDB_
     * @param testBundleId - Bundle id of the test to launch
     * @param appBundleId - Bundle id of the app to test
     * @param reportActivities - idb will report activity data emitted by your test bundle
     * @param reportAttachments - idb will report activity and attachment data emitted by your test bundle
     * @param collectCoverage - collect coverage or not
     * @param collectLogs - collect logs or not
     * @param waitForDebugger - Suspend test run process to wait for a debugger to be attached. (It is NOT supported by ui test).
     * @param collectResultBundle - collect result bundle or not
     * @param coverageFormat - Format for code coverage information: "
    "EXPORTED (default value) a file in JSON format as exported by `llvm-cov export`; "
    "RAW a folder containing the .profraw files as generated by the Test Bundle, Host App and/or Target App
     * @param testHostAppBundleId - Bundle id of the app that hosts ui test
     * @param testsToRun - Run these tests only. if not specified all tests are run. Format: className/methodName
     * @param testsToSkip - Skip these tests, has precedence over --tests-to-run. Format: className/methodName
     * @param env - env map
     * @param args - Arguments to start the test with
     * @param timeout - The number of seconds to wait before the test times out. When the timeout is exceeded the test
     * will exit and an attempt will be made to obtain a sample of the hung process
     */
    data class ApplicationXctestRequestBody(
        val testBundleId: String,
        val appBundleId: String,
        val reportActivities: Boolean,
        val reportAttachments: Boolean,
        val collectCoverage: Boolean,
        val collectLogs: Boolean,
        val waitForDebugger: Boolean,
        val collectResultBundle: Boolean,
        val coverageFormat: CodeCoverageFormat?, //required for collectCoverage = true
        val testHostAppBundleId: String = "",
        val testsToRun: List<String> = emptyList(),
        val testsToSkip: List<String> = emptyList(),
        val env: Map<String, String> = emptyMap(),
        val args: List<String> = emptyList(),
        val timeout: Long = 0L,
    ) : XctestRunRequestBody() {
        override val requestBody: XctestRunRequest = XctestRunRequest.newBuilder()
            .setMode(
                XctestRunRequest.Mode.newBuilder()
                    .setApplication(
                        XctestRunRequest.Application.newBuilder()
                            .setAppBundleId(appBundleId)
                            .build()
                    )
            )
            .setTestBundleId(testBundleId)
            .setReportActivities(reportActivities)
            .setReportAttachments(reportAttachments)
            .setCollectCoverage(collectCoverage)
            .setCollectLogs(collectLogs)
            .setWaitForDebugger(waitForDebugger)
            .setCollectResultBundle(collectResultBundle)
            .putAllEnvironment(env)
            .addAllArguments(args)
            .setTimeout(timeout)
            .addAllTestsToRun(testsToRun)
            .addAllTestsToSkip(testsToSkip)
            .build().apply {
                if(collectCoverage) {
                    this.toBuilder().setCodeCoverage(
                        XctestRunRequest.CodeCoverage.newBuilder().setFormatValue(coverageFormat?.value ?: 0).build()
                    ).build()
                }
            }
    }
}